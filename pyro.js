// Generated by CoffeeScript 1.9.3
(function() {
  var _, fs, ribcage, util;

  ribcage = require('ribcage');

  util = require('util');

  fs = require('fs');

  _ = require('underscore');

  ribcage.init({
    verboseInit: false
  }, function(err, env) {
    var compileForward, compileNat, hosts, pings, resolveHost, resolveHostArray, resolveHosts, rules;
    rules = env.settings.rules;
    if (!rules.forward) {
      rules.forward = [];
    }
    if (!rules.nat) {
      rules.nat = [];
    }
    hosts = env.settings.hosts;
    resolveHost = function(host) {
      var ref, resolvedHost;
      if (resolvedHost = (ref = hosts[host]) != null ? ref.ip : void 0) {
        return resolvedHost;
      } else {
        return host;
      }
    };
    resolveHostArray = function(host) {
      if (host.constructor === Array) {
        return _.map(host, resolveHost).join(',');
      } else {
        return resolveHost(host);
      }
    };
    resolveHosts = function(rule) {
      if (rule.from) {
        rule._fromName = rule.from;
        rule.from = resolveHostArray(rule.from);
      }
      if (rule.to) {
        rule._toName = rule.to;
        return rule.to = resolveHostArray(rule.to);
      }
    };
    _.map(hosts, function(host, hostName) {
      if (host.ports) {
        _.map(host.ports, function(port, portName) {
          var rule;
          rule = _.extend({}, _.pick(port, 'proto', 'port'));
          rule.to = host.ip;
          rule._toName = hostName;
          rule.from = port.from;
          rule.comment = port.from + " --> " + hostName + ":" + portName;
          return rules.forward.push(rule);
        });
      }
      if (host.publicPorts) {
        return _.map(host.publicPorts, function(port, portName) {
          var rule;
          rule = _.extend({}, _.pick(port, 'proto', 'port', 'internalPort'));
          rule.to = host.ip;
          rule._toName = hostName;
          rule.from = port.host;
          rule._portName = portName;
          return rules.nat.push(rule);
        });
      }
    });
    compileNat = function(rule) {
      var compiled, str;
      rule = _.extend({}, {
        proto: 'tcp'
      }, rule);
      resolveHosts(rule);
      compiled = ["iptables -A PREROUTING -t nat -p " + rule.proto + " -i eth0"];
      if (rule.port.constructor === Number) {
        compiled.push("--dport " + rule.port);
      } else {
        compiled.push("--match multiport --dports " + rule.port);
      }
      if (rule.from) {
        compiled.push("-d " + rule.from);
      }
      if (rule.from) {
        rule.comment = rule.from + ":" + rule.port + " --> " + rule._toName + ":" + (rule.internalPort || rule.port);
      } else {
        rule.comment = rule.port + " --> " + rule._toName + ":" + (rule.internalPort || rule.port);
      }
      if (!rule.internalPort) {
        compiled.push("-j DNAT --to " + rule.to);
      } else {
        compiled.push("-j DNAT --to " + rule.to + ":" + rule.internalPort);
      }
      str = compiled.join(' ');
      if (rule.comment) {
        str = "# " + rule.comment + "\n" + str;
      }
      return str;
    };
    compileForward = function(rule) {
      var compiled, str;
      compiled = ['iptables -A FORWARD'];
      if (rule.proto) {
        compiled.push("-p " + rule.proto);
      } else {
        compiled.push("-p tcp");
      }
      resolveHosts(rule);
      if (rule.to) {
        if (rule.to.indexOf('-') === -1) {
          compiled.push("-d " + rule.to);
        } else {
          compiled.push("-m iprange --dst-range " + rule.to);
        }
      }
      if (rule.from) {
        if (rule.from.indexOf('-') === -1) {
          compiled.push("-s " + rule.from);
        } else {
          compiled.push("-m iprange --src-range " + rule.from);
        }
      }
      if (rule.port) {
        if (rule.port.constructor === Number || rule.port.indexOf(':') === -1) {
          compiled.push("--dport " + rule.port);
        } else {
          compiled.push("--match multiport --dports " + rule.port);
        }
      }
      compiled.push("-m state --state NEW,ESTABLISHED,RELATED -j ACCEPT");
      str = compiled.join(' ');
      if (rule.comment) {
        str = "# " + rule.comment + "\n" + str;
      }
      return str;
    };
    console.log("# NAT\n");
    _.each(rules.nat, function(rule) {
      console.log(compileNat(rule));
      delete rule.from;
      if (rule.internalPort) {
        rule.port = rule.internalPort;
      }
      return console.log(compileForward(rule));
    });
    console.log("\n# INTERNAL CONNECTIONS\n");
    _.each(rules.forward, function(rule) {
      return console.log(compileForward(rule));
    });
    console.log("\n# INTERNAL PINGS\n");
    pings = [];
    _.each(rules.forward, function(rule) {
      if (!rule.from) {
        return;
      }
      if (!_.find(pings, function(entry) {
        return entry.from === rule.from && entry.to === rule.to;
      })) {
        return pings.push({
          from: rule.from,
          to: rule.to,
          comment: rule._fromName + " -- ping -> " + rule._toName
        });
      }
    });
    return _.each(pings, function(rule) {
      var compiled;
      compiled = ['iptables -A FORWARD'];
      resolveHosts(rule);
      if (rule.from.indexOf('-') === -1) {
        compiled.push("-s " + rule.from);
      } else {
        compiled.push("-m iprange --src-range " + rule.from);
      }
      if (rule.to.indexOf('-') === -1) {
        compiled.push("-d " + rule.to);
      } else {
        compiled.push("-m iprange --dst-range " + rule.to);
      }
      compiled.push('-p icmp --icmp-type echo-request -j ACCEPT');
      if (rule.comment) {
        console.log("# " + rule.comment);
      }
      return console.log(compiled.join(' '));
    });
  });

}).call(this);
